1- Proba das GNU Arm EMbedded Toolchain

	1.8- En la compilación con cortex-a7 se observa una estructura distinta pero parecida a la de cortex-m0, mientras que la de gcc es bastante diferente, ya que son compilaciones diseñadas para cpus distintas (por ejemplo: cortex-a7 para raspberry-pi)

	1.9- Se puede apreciar una simplificación grande del código ensamblador, esto se debe a que hemos usado -O2 que se trata de una opción de optimización, mientras que -O0 no optimiza nada el código a compilar. Si añadimos un printf() al programa y compilamos con -O2 con gcc, vemos que el código ensamblador del programa que tiene el printf() es más amplio que el que no lo tiene, esto se debe a que dentro del main() estamos usando la c para algo, y obligamos al ensamblador a tenerla en cuenta, mientras que en el programa sin printf(), el compilador suprime las acciones de la función main().

	1.10- El de los apuntes está escrito a mano por una persona, por lo que es menos óptimo que el realizado por el compilador.




2- Simulación con QtARMSim

	2.1- Es mucho más sencillo ya que en este simplemente cargamos los valores 5 en el registro 0 (movs r0, #5) y 4 en el registro 1 (movs r1, #4) y a continuación los sumamos y cargamos el resultado en el registro 2 (adds r2, r1, r0)

	2.2- Como era de esperar realiza la suma y carga el resultado en el registro 2, ninguna de las flags se activa,
		ADD -> carga el resultado en el primer registro que se escriba (ADD r2, __, __) de la suma de los registros indicados (ADD __, r1, r0)
		MOV -> carga los datos en el registro indicado (MOV r0, #5)

	2.3- Se activa la flag "N", que nos indica que el resultado es negativo (4-5=-1)

	2.4- Salta el error: "Error: instruction not supported in Thumb16 mode -- `adds r2,r1,r0'", esto se debe a que antiguamente se usaba únicamente la instrucción 'add'.

	2.5- Para obtener las flags C y V con la suma, debemos definir los valores de r0 y r1 a 2, y desplazarlos a la izquierda 30 veces (con la instrucciín 'lsl') y realizar la suma.
	En la resta, para obtener las flags C y V definiremos r0 como 2 y r1 como 2 (mov r1, #2) y lo desplazamos a la izquierda 30 veces (lsl r1, #30) y realizaremos la resta r1 menos r0 y almacenamos el resultado en r2 (sub r2, r1, r0)

	2.7- Las instrucciones dentro de main() son muy similares a las que se compiló en 1.5, en cuanto a las definiciones, las de QtARMSim son más breves.

	2.8- 	.data -> Se utiliza para avisar al ensamblador de que todo lo que aparezca debajo de esta directiva (mientras no se diga lo contrario) debe ser almacenado en la zona de datos.
		.word -> Indica al ensamblador que se quiere reservar espacio para una palabra e inicializarlo con un determinado valor.
		.space -> Se usa para reservar X bytes de memoria e inicializarlos a 0.
		.text -> Indica al ensamblador que lo que viene a continuación es el programa en ensamblador y que debe colocar las instrucciones que lo forman en la zona de memoria asignada al código ejecutable.
